---
name: iso27001
description: Expert implementation ISO 27001 - SMSI, controles Annex A
---

# ISO 27001 Implementation

Tu es expert en **implementation technique ISO 27001**.

## Mission

> Implementer les controles techniques du Systeme de Management de la Securite de l'Information.

## Structure ISO 27001

```
ISO 27001
    |
    +-- Clauses 4-10 (Management Requirements)
    |
    +-- Annex A (114 Controls in 14 domains)
            |
            +-- A.5 Information Security Policies
            +-- A.6 Organization
            +-- A.7 Human Resources
            +-- A.8 Asset Management
            +-- A.9 Access Control
            +-- A.10 Cryptography
            +-- A.11 Physical Security
            +-- A.12 Operations Security
            +-- A.13 Communications Security
            +-- A.14 System Acquisition
            +-- A.15 Supplier Relationships
            +-- A.16 Incident Management
            +-- A.17 Business Continuity
            +-- A.18 Compliance
```

## A.9 Access Control

### A.9.1 Business Requirements

```typescript
// Politique d'access control
interface AccessPolicy {
  resource: string;
  allowedRoles: string[];
  conditions?: {
    timeRestriction?: { start: number; end: number };
    ipWhitelist?: string[];
    mfaRequired?: boolean;
  };
}

const accessPolicies: AccessPolicy[] = [
  {
    resource: '/admin/*',
    allowedRoles: ['admin'],
    conditions: {
      mfaRequired: true,
      ipWhitelist: ['10.0.0.0/8'],
    }
  },
  {
    resource: '/api/users',
    allowedRoles: ['admin', 'manager'],
    conditions: {
      timeRestriction: { start: 8, end: 18 }
    }
  }
];

// Enforcement
function enforceAccessPolicy(req: Request, policy: AccessPolicy): boolean {
  // Check role
  if (!policy.allowedRoles.includes(req.user.role)) {
    return false;
  }

  // Check conditions
  if (policy.conditions) {
    const { timeRestriction, ipWhitelist, mfaRequired } = policy.conditions;

    if (mfaRequired && !req.user.mfaVerified) {
      return false;
    }

    if (timeRestriction) {
      const hour = new Date().getHours();
      if (hour < timeRestriction.start || hour > timeRestriction.end) {
        return false;
      }
    }

    if (ipWhitelist && !isIpInRange(req.ip, ipWhitelist)) {
      return false;
    }
  }

  return true;
}
```

### A.9.2 User Access Management

```typescript
// Provisioning / Deprovisioning automatise
interface UserLifecycle {
  onboarding: (user: User) => Promise<void>;
  offboarding: (user: User) => Promise<void>;
  accessReview: () => Promise<void>;
}

const userLifecycle: UserLifecycle = {
  async onboarding(user) {
    // Creer les comptes selon le role
    const permissions = rolePermissions[user.role];

    await Promise.all([
      createGitHubAccess(user, permissions.github),
      createAWSAccess(user, permissions.aws),
      createSlackAccess(user),
      logAccessGrant(user, permissions),
    ]);
  },

  async offboarding(user) {
    // Revoquer tous les acces
    await Promise.all([
      revokeGitHubAccess(user),
      revokeAWSAccess(user),
      revokeSlackAccess(user),
      invalidateSessions(user),
      logAccessRevocation(user),
    ]);
  },

  async accessReview() {
    // Revue trimestrielle
    const users = await db.user.findMany({ where: { status: 'active' } });

    for (const user of users) {
      const lastActivity = await getLastActivity(user.id);
      const daysSinceActivity = differenceInDays(new Date(), lastActivity);

      if (daysSinceActivity > 90) {
        await flagForReview(user, 'Inactive for 90+ days');
      }

      // Verifier coherence role/permissions
      const actualPermissions = await getActualPermissions(user);
      const expectedPermissions = rolePermissions[user.role];

      if (!isEqual(actualPermissions, expectedPermissions)) {
        await flagForReview(user, 'Permission drift detected');
      }
    }
  }
};
```

## A.10 Cryptography

```typescript
// A.10.1 Cryptographic Controls
const cryptoPolicy = {
  // Algorithmes approuves
  symmetric: ['AES-256-GCM'],
  asymmetric: ['RSA-2048', 'RSA-4096', 'ECDSA-P256'],
  hashing: ['SHA-256', 'SHA-384', 'SHA-512'],
  passwordHashing: ['Argon2id', 'bcrypt'],

  // Key management
  keyRotation: {
    encryptionKeys: '365d',
    signingKeys: '365d',
    sessionKeys: '24h',
  },

  // TLS policy
  tls: {
    minVersion: 'TLSv1.2',
    preferredVersion: 'TLSv1.3',
    cipherSuites: [
      'TLS_AES_256_GCM_SHA384',
      'TLS_CHACHA20_POLY1305_SHA256',
    ]
  }
};

// Validation en CI
function validateCryptoUsage(codebase: string): ValidationResult {
  const issues: Issue[] = [];

  // Detecter algorithmes faibles
  const weakPatterns = [
    /MD5|SHA1|DES|RC4|ECB/gi,
    /createCipher\(/,  // Deprecated
    /Math\.random\(\)/,
  ];

  for (const pattern of weakPatterns) {
    const matches = codebase.match(pattern);
    if (matches) {
      issues.push({ severity: 'high', pattern: pattern.toString() });
    }
  }

  return { valid: issues.length === 0, issues };
}
```

## A.12 Operations Security

### A.12.4 Logging and Monitoring

```typescript
// Centralized logging
interface SecurityLog {
  timestamp: Date;
  level: 'info' | 'warn' | 'error' | 'critical';
  category: 'access' | 'change' | 'security' | 'system';
  actor: string;
  action: string;
  resource: string;
  outcome: 'success' | 'failure';
  details: Record<string, unknown>;
  ip?: string;
  userAgent?: string;
}

const securityLogger = {
  log(event: Partial<SecurityLog>) {
    const log: SecurityLog = {
      timestamp: new Date(),
      level: 'info',
      ...event,
    } as SecurityLog;

    // Envoyer au SIEM
    siemClient.send(log);

    // Stocker localement
    db.securityLog.create({ data: log });

    // Alerter si critique
    if (log.level === 'critical') {
      alertSecurityTeam(log);
    }
  },

  accessLog(req: Request, outcome: 'success' | 'failure') {
    this.log({
      category: 'access',
      actor: req.user?.id || 'anonymous',
      action: `${req.method} ${req.path}`,
      resource: req.path,
      outcome,
      ip: req.ip,
      userAgent: req.headers['user-agent'],
    });
  },

  changeLog(actor: string, resource: string, changes: object) {
    this.log({
      category: 'change',
      actor,
      action: 'modify',
      resource,
      outcome: 'success',
      details: changes,
    });
  }
};
```

### A.12.6 Vulnerability Management

```typescript
// Scan automatise et tracking
interface Vulnerability {
  id: string;
  cve?: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  component: string;
  version: string;
  fixedVersion?: string;
  discoveredAt: Date;
  status: 'open' | 'in_progress' | 'resolved' | 'accepted';
  assignee?: string;
  dueDate: Date;
}

// SLA de remediation
const remediationSLA = {
  critical: 1,   // 1 jour
  high: 7,       // 7 jours
  medium: 30,    // 30 jours
  low: 90,       // 90 jours
};

// Pipeline de scan
async function runVulnerabilityScan() {
  const results = await Promise.all([
    runDependencyAudit(),  // npm audit, snyk
    runContainerScan(),    // Trivy
    runSASTScan(),         // Semgrep
  ]);

  for (const vuln of results.flat()) {
    const existing = await db.vulnerability.findFirst({
      where: { cve: vuln.cve, component: vuln.component }
    });

    if (!existing) {
      await db.vulnerability.create({
        data: {
          ...vuln,
          status: 'open',
          dueDate: addDays(new Date(), remediationSLA[vuln.severity]),
        }
      });

      // Alerter si critique
      if (vuln.severity === 'critical') {
        await alertSecurityTeam({
          type: 'critical_vulnerability',
          vuln,
        });
      }
    }
  }
}
```

## A.16 Incident Management

```typescript
// A.16.1 Incident Response
interface SecurityIncident {
  id: string;
  title: string;
  severity: 1 | 2 | 3 | 4;  // 1 = critical
  status: 'detected' | 'analyzing' | 'containing' | 'eradicating' | 'recovering' | 'closed';
  detectedAt: Date;
  detectedBy: string;
  description: string;
  affectedSystems: string[];
  timeline: IncidentEvent[];
  rootCause?: string;
  lessonsLearned?: string;
}

// Workflow incident
const incidentWorkflow = {
  async detect(incident: Partial<SecurityIncident>) {
    const created = await db.incident.create({
      data: {
        ...incident,
        status: 'detected',
        detectedAt: new Date(),
      }
    });

    // Alerter l'equipe
    await notifyIncidentTeam(created);
    await createWarRoom(created);  // Slack channel

    return created;
  },

  async updateStatus(id: string, status: SecurityIncident['status'], notes: string) {
    await db.incident.update({
      where: { id },
      data: { status }
    });

    await db.incidentEvent.create({
      data: {
        incidentId: id,
        timestamp: new Date(),
        action: `Status changed to ${status}`,
        notes,
      }
    });
  },

  async close(id: string, rootCause: string, lessonsLearned: string) {
    await db.incident.update({
      where: { id },
      data: {
        status: 'closed',
        rootCause,
        lessonsLearned,
        closedAt: new Date(),
      }
    });

    // Generer post-mortem
    await generatePostMortem(id);
  }
};
```

## Statement of Applicability (SoA)

```typescript
// Tracking des controles
interface Control {
  id: string;           // e.g., "A.9.1.1"
  title: string;
  applicable: boolean;
  justification: string;
  implementationStatus: 'not_started' | 'partial' | 'implemented';
  evidence: string[];
  owner: string;
  lastReview: Date;
}

// Dashboard SoA
app.get('/admin/iso27001/soa', adminMiddleware, async (req, res) => {
  const controls = await db.control.findMany();

  const summary = {
    total: controls.length,
    applicable: controls.filter(c => c.applicable).length,
    implemented: controls.filter(c => c.implementationStatus === 'implemented').length,
    partial: controls.filter(c => c.implementationStatus === 'partial').length,
    notStarted: controls.filter(c => c.implementationStatus === 'not_started').length,
  };

  res.json({ controls, summary });
});
```

## Checklist ISO 27001

### SMSI
- [ ] Scope defini
- [ ] Politique de securite
- [ ] Risk assessment
- [ ] Statement of Applicability
- [ ] Risk treatment plan

### Controles Techniques
- [ ] Access control (A.9)
- [ ] Cryptography (A.10)
- [ ] Operations security (A.12)
- [ ] Communications security (A.13)
- [ ] Incident management (A.16)

### Evidence
- [ ] Logs centralises
- [ ] Revue des acces
- [ ] Vulnerability scans
- [ ] Incident reports
- [ ] Training records

## Voir Aussi

- `compliance/soc2` pour mapping SOC2
- `threat-modeling/risk-assessment` pour evaluation risques
- `devops/monitoring` pour logging
